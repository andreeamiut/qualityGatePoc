name: ğŸš€ Production Deployment

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      force_deploy:
        description: 'Force deployment (skip quality gates)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ==========================================
  # Pre-Deployment Validation
  # ==========================================
  pre-deployment:
    name: ğŸ” Pre-Deployment Validation
    runs-on: ubuntu-latest
    outputs:
      deployment-approved: ${{ steps.validation.outputs.approved }}
      
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Quality Gate Check
      id: validation
      run: |
        echo "ğŸ” Running pre-deployment quality validation..."
        
        # Start services for validation
        docker compose up -d
        sleep 30
        
        # Run our comprehensive CI/CD pipeline validation
        docker cp cicd_pipeline.sh qualitygatepoc-automation-1:/opt/automation/
        
        PIPELINE_RESULT=$(docker exec qualitygatepoc-automation-1 bash -c "
          cd /opt/automation
          chmod +x cicd_pipeline.sh
          ./cicd_pipeline.sh
        ")
        
        echo "$PIPELINE_RESULT"
        
        if echo "$PIPELINE_RESULT" | grep -q "CI/CD PIPELINE: SUCCESS"; then
          echo "âœ… Pre-deployment validation PASSED"
          echo "approved=true" >> $GITHUB_OUTPUT
        elif [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
          echo "âš ï¸ Validation failed but force deployment enabled"
          echo "approved=true" >> $GITHUB_OUTPUT
        else
          echo "âŒ Pre-deployment validation FAILED"
          echo "approved=false" >> $GITHUB_OUTPUT
        fi
        
        # Cleanup
        docker compose down -v

  # ==========================================
  # Build & Push Container Images
  # ==========================================
  build-images:
    name: ğŸ—ï¸ Build & Push Images
    runs-on: ubuntu-latest
    needs: pre-deployment
    if: needs.pre-deployment.outputs.deployment-approved == 'true'
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ³ Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: ğŸ”‘ Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: ğŸ“Š Extract Metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-

    - name: ğŸ—ï¸ Build & Push Application Image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: ğŸ“‹ Generate Deployment Manifest
      run: |
        cat << EOF > deployment-manifest.yml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: qualitygate-api
          labels:
            app: qualitygate-api
            version: ${{ github.sha }}
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: qualitygate-api
          template:
            metadata:
              labels:
                app: qualitygate-api
                version: ${{ github.sha }}
            spec:
              containers:
              - name: api
                image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
                ports:
                - containerPort: 5000
                env:
                - name: DATABASE_URL
                  valueFrom:
                    secretKeyRef:
                      name: db-credentials
                      key: url
                livenessProbe:
                  httpGet:
                    path: /health
                    port: 5000
                  initialDelaySeconds: 30
                  periodSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /health
                    port: 5000
                  initialDelaySeconds: 5
                  periodSeconds: 5
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: qualitygate-api-service
        spec:
          selector:
            app: qualitygate-api
          ports:
          - protocol: TCP
            port: 80
            targetPort: 5000
          type: LoadBalancer
        EOF

    - name: ğŸ“¤ Upload Deployment Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: deployment-artifacts
        path: |
          deployment-manifest.yml
          docker-compose.prod.yml

  # ==========================================
  # Staging Deployment
  # ==========================================
  deploy-staging:
    name: ğŸš€ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [pre-deployment, build-images]
    if: needs.pre-deployment.outputs.deployment-approved == 'true'
    environment: 
      name: staging
      url: https://staging.qualitygate.example.com
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ“¥ Download Artifacts
      uses: actions/download-artifact@v4
      with:
        name: deployment-artifacts

    - name: ğŸš€ Deploy to Staging Environment
      run: |
        echo "ğŸš€ Deploying to staging environment..."
        
        # Simulate deployment process
        echo "  ğŸ“¦ Pulling latest container images..."
        echo "  ğŸ”§ Updating configuration..."
        echo "  â™»ï¸  Rolling update deployment..."
        echo "  ğŸ©º Health check validation..."
        
        # In a real scenario, this would deploy to your staging infrastructure
        # kubectl apply -f deployment-manifest.yml
        # helm upgrade qualitygate ./helm-chart --set image.tag=${{ github.sha }}
        
        echo "âœ… Staging deployment completed successfully!"

    - name: ğŸ§ª Post-Deployment Validation
      run: |
        echo "ğŸ§ª Running post-deployment validation..."
        
        # Simulate post-deployment tests
        echo "  âœ… Application health check: PASSED"
        echo "  âœ… Database connectivity: PASSED"  
        echo "  âœ… API endpoints: PASSED"
        echo "  âœ… Performance benchmarks: PASSED"
        
        echo "ğŸ‰ Staging environment validation completed!"

  # ==========================================
  # Production Deployment (Manual Approval)
  # ==========================================
  deploy-production:
    name: ğŸ† Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment, build-images, deploy-staging]
    if: |
      needs.pre-deployment.outputs.deployment-approved == 'true' && 
      (github.event_name == 'release' || github.event.inputs.environment == 'production')
    environment: 
      name: production
      url: https://api.qualitygate.example.com
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ“¥ Download Artifacts
      uses: actions/download-artifact@v4
      with:
        name: deployment-artifacts

    - name: ğŸ† Deploy to Production Environment
      run: |
        echo "ğŸ† Deploying to PRODUCTION environment..."
        echo "âš ï¸  This is a production deployment - proceeding with caution"
        
        echo "  ğŸ“¦ Pulling production container images..."
        echo "  ğŸ”§ Applying production configuration..."
        echo "  ğŸ“Š Creating deployment backup..."
        echo "  â™»ï¸  Blue-green deployment process..."
        echo "  ğŸ©º Production health validation..."
        
        # In a real scenario, this would deploy to your production infrastructure
        # kubectl apply -f deployment-manifest.yml --namespace=production
        # helm upgrade qualitygate ./helm-chart --set image.tag=${{ github.sha }} --namespace=production
        
        echo "âœ… PRODUCTION deployment completed successfully!"

    - name: ğŸ§ª Production Smoke Tests
      run: |
        echo "ğŸ§ª Running production smoke tests..."
        
        # Simulate production validation
        echo "  âœ… Production API health: PASSED"
        echo "  âœ… Database performance: PASSED"
        echo "  âœ… Cache layer: PASSED"
        echo "  âœ… Monitoring integration: PASSED"
        echo "  âœ… Load balancer: PASSED"
        
        echo "ğŸ‰ Production deployment validation completed!"

    - name: ğŸ“¢ Production Deployment Notification
      run: |
        echo "ğŸ“¢ PRODUCTION DEPLOYMENT SUCCESSFUL! ğŸ‰"
        echo ""
        echo "ğŸ† Deployment Details:"
        echo "  â€¢ Version: ${{ github.sha }}"
        echo "  â€¢ Environment: Production"
        echo "  â€¢ Deployed by: ${{ github.actor }}"
        echo "  â€¢ Deployment time: $(date)"
        echo ""
        echo "ğŸ”— Production URL: https://api.qualitygate.example.com"
        echo "ğŸ“Š Monitoring: https://monitoring.qualitygate.example.com"

  # ==========================================
  # Post-Deployment Monitoring
  # ==========================================
  monitor-deployment:
    name: ğŸ“Š Post-Deployment Monitoring
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    
    steps:
    - name: ğŸ“Š Setup Monitoring
      run: |
        echo "ğŸ“Š Setting up post-deployment monitoring..."
        
        # Simulate monitoring setup
        echo "  ğŸ“ˆ Performance metrics collection: ACTIVE"
        echo "  ğŸš¨ Error rate alerting: CONFIGURED"
        echo "  ğŸ“± Notification channels: READY"
        echo "  ğŸ” Health check monitoring: ENABLED"

    - name: â° Schedule Health Checks
      run: |
        echo "â° Scheduling automated health checks..."
        
        # In a real scenario, this would configure monitoring systems
        echo "  â€¢ 5-minute health check intervals"
        echo "  â€¢ Performance threshold alerting"
        echo "  â€¢ Automated rollback triggers"
        echo "  â€¢ Incident response automation"

    - name: ğŸ“ˆ Deployment Success Metrics
      run: |
        echo "ğŸ“ˆ Recording deployment success metrics..."
        echo "  âœ… Deployment completed without issues"
        echo "  âœ… All health checks passing"
        echo "  âœ… Performance within acceptable limits"
        echo "  âœ… Zero-downtime deployment achieved"
